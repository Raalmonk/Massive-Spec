<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFLorrgs - Timeline Canvas</title>
    <style>
        body { margin: 0; background-color: #121212; color: white; overflow: hidden; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 4px;
        }
    </style>
    <script src="api.js"></script>
</head>
<body>
    <div id="controls">
        <span id="status">Waiting for data...</span>
    </div>
    <canvas id="timelineCanvas"></canvas>
    <script>
        const canvas = document.getElementById("timelineCanvas");
        const ctx = canvas.getContext("2d");

        // Config
        const PIXELS_PER_SECOND = 30;
        const ROW_HEIGHT = 50;

        // Resize canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Re-render if we have data
            if (window.lastFightData && window.lastSpellMap) {
                renderTimeline(window.lastFightData, window.lastSpellMap);
            }
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Helper to preload images
        async function preloadSpellImages(spellMap) {
            const promises = [];
            Object.values(spellMap).forEach(spell => {
                // Check for 'icon' or 'image' field
                const iconUrl = spell.icon || spell.image;
                if (iconUrl) {
                    const img = new Image();
                    img.src = iconUrl;
                    spell.imageObj = img; // Attach to spell object
                    promises.push(new Promise((resolve) => {
                        img.onload = () => { spell.imageLoaded = true; resolve(); };
                        img.onerror = () => { spell.imageLoaded = false; resolve(); };
                    }));
                }
            });
            // Wait for all images to try loading
            await Promise.all(promises);
        }

        // 2. Render Main Function
        function renderTimeline(fightData, spellMap) {
            // Save for resize
            window.lastFightData = fightData;
            window.lastSpellMap = spellMap;

            // Clear canvas
            ctx.fillStyle = "#121212";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!fightData || !fightData.players) return;

            // Iterate Players
            fightData.players.forEach((player, index) => {
                const rowY = index * ROW_HEIGHT;

                // Draw Track Background
                ctx.fillStyle = (index % 2 === 0) ? "#1a1a1a" : "#222";
                ctx.fillRect(0, rowY, canvas.width, ROW_HEIGHT);

                // Draw Player Name
                ctx.fillStyle = "#eee";
                ctx.font = "14px Arial";
                ctx.fillText(player.name, 10, rowY + 30);

                // Iterate Casts
                if (player.casts) {
                    player.casts.forEach(cast => {
                        // [Core Filtering Logic]
                        const spellInfo = spellMap[cast.spell_id];
                        if (!spellInfo) {
                            return; // Skip if not in whitelist
                        }

                        // Calculate X
                        const timeSeconds = cast.timestamp / 1000;
                        const x = timeSeconds * PIXELS_PER_SECOND;

                        // Draw Spell (Icon or Rect)
                        if (spellInfo.imageLoaded && spellInfo.imageObj) {
                            // Draw Icon
                            ctx.drawImage(spellInfo.imageObj, x, rowY + 10, 30, 30);
                        } else {
                            // Fallback: Rect
                            ctx.fillStyle = spellInfo.color || "#ffcc00";
                            ctx.fillRect(x, rowY + 10, 30, 30);
                        }

                        // (Optional) Draw name
                        // ctx.fillStyle = "white";
                        // ctx.fillText(spellInfo.name, x, rowY + 50);
                    });
                }
            });
            
            document.getElementById('status').innerText = "Rendered!";
        }

        // Bridge function called by api.js
        async function renderCanvas(fightData, specSlug) {
            document.getElementById('status').innerText = "Loading Spells...";

            // If specSlug is not passed, use default
            if (!specSlug) specSlug = "redmage-redmage";

            let spellMap = {};
            try {
                spellMap = await loadSpellData(specSlug);
                // Preload images
                await preloadSpellImages(spellMap);
            } catch (e) {
                console.error("Failed to load spell map", e);
            }

            renderTimeline(fightData, spellMap);
        }

        // Init
        const urlParams = new URLSearchParams(window.location.search);
        // Default to a known report/fight if available, or just placeholders
        const reportId = urlParams.get('report') || 'test_report';
        const fightId = urlParams.get('fight') || 'test_fight';
        const specSlug = urlParams.get('spec') || 'redmage-redmage';

        console.log("Starting loadFightData...");
        loadFightData(reportId, fightId, specSlug);

    </script>
</body>
</html>
